import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { createCCBClient, type LinkRow } from '../../../../lib/ccb/ccb-client';

export const dynamic = 'force-dynamic';

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SYNC_MONTHS = 6;

// â”€â”€ Supabase service client (bypasses RLS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getServiceClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

// â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interface OccurrenceRow {
  leader_id: number;
  ccb_event_id: string | null;
  meeting_date: string; // YYYY-MM-DD
  status: 'met' | 'did_not_meet' | 'no_record';
  headcount: number | null;
  regular_count: number | null;
  visitor_count: number | null;
  source: 'ccb' | 'manual' | 'event_summary';
  raw_payload: any;
  attendees: { ccb_individual_id: string; name: string; attendance_type: string }[];
}

interface LeaderRow {
  id: number;
  name: string;
  ccb_group_id: string;
  day: string | null;
  frequency: string | null;
  meeting_start_date: string | null;
}

// â”€â”€ Day-of-week helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DAY_MAP: Record<string, number> = {
  sunday: 0, monday: 1, tuesday: 2, wednesday: 3,
  thursday: 4, friday: 5, saturday: 6,
};

/**
 * Determine all dates in [startDate, endDate] that fall on the leader's
 * meeting day. In the future we can incorporate biweekly parity via
 * meeting_start_date.
 */
function getExpectedMeetingDates(
  leader: LeaderRow,
  startDate: string,
  endDate: string
): string[] {
  if (!leader.day) return [];

  const targetDay = DAY_MAP[leader.day.toLowerCase().trim()];
  if (targetDay === undefined) return [];

  const dates: string[] = [];
  const cursor = new Date(startDate + 'T12:00:00');
  const end = new Date(endDate + 'T12:00:00');

  while (cursor <= end) {
    if (cursor.getDay() === targetDay) {
      dates.push(cursor.toISOString().split('T')[0]);
    }
    cursor.setDate(cursor.getDate() + 1);
  }

  // Biweekly filter: keep every other meeting based on anchor date
  if (leader.frequency?.toLowerCase().includes('bi') && leader.meeting_start_date) {
    const anchor = new Date(leader.meeting_start_date + 'T12:00:00');
    const anchorTime = anchor.getTime();
    const oneWeekMs = 7 * 24 * 60 * 60 * 1000;
    return dates.filter(d => {
      const diff = Math.abs(new Date(d + 'T12:00:00').getTime() - anchorTime);
      const weeksDiff = Math.round(diff / oneWeekMs);
      return weeksDiff % 2 === 0;
    });
  }

  return dates;
}

/**
 * Build OccurrenceRow records from pre-fetched LinkRow data for a single leader.
 * No CCB API calls here â€” all data comes from the bulk fetch.
 */
function buildOccurrenceRows(
  leader: LeaderRow,
  linkRows: LinkRow[]
): OccurrenceRow[] {
  const records: OccurrenceRow[] = [];

  for (const row of linkRows) {
    const att = row.attendance;
    if (!att) continue;

    const meetingDate = row.occurDate;
    if (!meetingDate) continue;

    let regularCount = 0;
    let visitorCount = 0;
    const attendees: OccurrenceRow['attendees'] = [];

    if (att.attendees) {
      for (const a of att.attendees) {
        const isVisitor = a.status?.toLowerCase().includes('visit') || false;
        if (isVisitor) visitorCount++;
        else regularCount++;

        attendees.push({
          ccb_individual_id: a.id || '',
          name: a.name || 'Unknown',
          attendance_type: isVisitor ? 'visitor' : 'regular',
        });
      }
    }

    records.push({
      leader_id: leader.id,
      ccb_event_id: att.eventId || row.eventId || null,
      meeting_date: meetingDate,
      status: att.didNotMeet ? 'did_not_meet' : 'met',
      headcount: att.headCount ?? (attendees.length || null),
      regular_count: regularCount || null,
      visitor_count: visitorCount || null,
      source: 'ccb',
      raw_payload: {
        eventId: att.eventId,
        title: att.title,
        occurrence: att.occurrence,
        headCount: att.headCount,
        didNotMeet: att.didNotMeet,
        topic: att.topic,
        notes: att.notes,
        attendeeCount: att.attendees?.length,
      },
      attendees,
    });
  }

  return records;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POST â€” trigger a full sync
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function POST(request: NextRequest) {
  // Auth: accept CRON_SECRET or skip check if not configured
  const cronSecret = process.env.CRON_SECRET;
  if (cronSecret) {
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
  }

  const supabase = getServiceClient();

  // Date range: rolling 6 months
  const endDate = new Date().toISOString().split('T')[0];
  const startObj = new Date();
  startObj.setMonth(startObj.getMonth() - SYNC_MONTHS);
  const startDate = startObj.toISOString().split('T')[0];

  // Optional: sync a single leader via ?leaderId=123
  const url = new URL(request.url);
  const singleLeaderId = url.searchParams.get('leaderId');

  // Load leaders with a CCB group ID
  let query = supabase
    .from('circle_leaders')
    .select('id, name, ccb_group_id, day, frequency, meeting_start_date')
    .not('ccb_group_id', 'is', null);

  if (singleLeaderId) {
    query = query.eq('id', parseInt(singleLeaderId, 10));
  }

  const { data: leaders, error: leadersError } = await query;

  if (leadersError || !leaders) {
    return NextResponse.json(
      { error: 'Failed to load leaders', details: leadersError },
      { status: 500 }
    );
  }

  // Filter out inactive/removed leaders (unless syncing a specific one)
  const activeLeaders = singleLeaderId
    ? (leaders as LeaderRow[])
    : (leaders as any[]).filter(
        (l) => !['Inactive', 'Removed', 'off-boarding'].includes(l.status || '')
      ) as LeaderRow[];

  let ccbClient: ReturnType<typeof createCCBClient>;
  try {
    ccbClient = createCCBClient();
  } catch (err: any) {
    return NextResponse.json(
      { error: 'CCB client initialization failed', details: err.message },
      { status: 500 }
    );
  }

  const results = {
    synced: 0,
    errors: 0,
    noRecordFilled: 0,
    leadersProcessed: 0,
    skippedNoCCBGroup: 0,
    ccbEventsTotal: 0,
    ccbGroupsMatched: 0,
  };

  // â”€â”€ Phase 1: Get event IDs per leader (before the big attendance call) â”€â”€
  // We do this FIRST to avoid rate limiting â€” the bulk attendance_profiles call
  // is 24 MB and exhausts CCB's rate window.
  console.log(`ðŸ“¦ Phase 1: Resolving event IDs for ${activeLeaders.length} leadersâ€¦`);
  const leaderEventMap = new Map<number, { leader: LeaderRow; eventIds: string[] }>();

  for (const leader of activeLeaders) {
    if (!leader.ccb_group_id) {
      results.skippedNoCCBGroup++;
      continue;
    }

    results.leadersProcessed++;

    // Throttle: 1 second between calls to stay under CCB rate limit
    if (leaderEventMap.size > 0) {
      await new Promise((r) => setTimeout(r, 1000));
    }

    const eventIds = await ccbClient.getGroupEventIds(leader.ccb_group_id);
    leaderEventMap.set(leader.id, { leader, eventIds });
    console.log(`  â†’ ${leader.name} (group ${leader.ccb_group_id}): ${eventIds.length} event IDs`);
  }

  // â”€â”€ Phase 2: Bulk fetch ALL attendance data (single API call) â”€â”€
  // Wait a bit for rate limit to cool down after Phase 1
  console.log(`ðŸ“¦ Phase 2: Fetching all attendance data from CCB: ${startDate} â†’ ${endDate}â€¦`);
  await new Promise((r) => setTimeout(r, 3000));

  let attendanceByEventId: Map<string, LinkRow[]>;
  try {
    attendanceByEventId = await ccbClient.fetchAllAttendanceInRange(
      startDate,
      endDate,
      { includeAttendees: true }
    );
  } catch (err: any) {
    return NextResponse.json(
      { error: 'CCB bulk attendance fetch failed', details: err.message },
      { status: 500 }
    );
  }

  let totalCCBEvents = 0;
  attendanceByEventId.forEach((rows) => { totalCCBEvents += rows.length; });
  results.ccbEventsTotal = totalCCBEvents;
  console.log(`ðŸ“¦ Phase 2 done: ${totalCCBEvents} attendance records across ${attendanceByEventId.size} event IDs`);

  // â”€â”€ Phase 3: Cross-reference and upsert â”€â”€
  console.log(`ðŸ“¦ Phase 3: Cross-referencing and upsertingâ€¦`);

  for (const [leaderId, { leader, eventIds }] of Array.from(leaderEventMap)) {
    try {
      // Cross-reference: collect attendance rows that match this group's events
      const groupRows: LinkRow[] = [];
      for (const eid of eventIds) {
        const rows = attendanceByEventId.get(eid);
        if (rows) groupRows.push(...rows);
      }

      if (groupRows.length > 0) results.ccbGroupsMatched++;
      console.log(`  â†’ ${leader.name}: ${eventIds.length} event IDs â†’ ${groupRows.length} attendance records`);

      // 1. Build occurrence rows from the cross-referenced data (no extra API call)
      const ccbRecords = buildOccurrenceRows(leader, groupRows);

      // 2. Build set of dates we got from CCB
      const ccbDates = new Set(ccbRecords.map((r) => r.meeting_date));

      // 3. Fill missing expected meeting dates with 'no_record'
      const expectedDates = getExpectedMeetingDates(leader, startDate, endDate);
      const today = new Date().toISOString().split('T')[0];
      const missingRecords: OccurrenceRow[] = expectedDates
        .filter((d) => !ccbDates.has(d) && d <= today) // Don't project future dates
        .map((d) => ({
          leader_id: leader.id,
          ccb_event_id: null,
          meeting_date: d,
          status: 'no_record' as const,
          headcount: null,
          regular_count: null,
          visitor_count: null,
          source: 'ccb' as const,
          raw_payload: null,
          attendees: [],
        }));

      results.noRecordFilled += missingRecords.length;

      const allRecords = [...ccbRecords, ...missingRecords];

      // 4. Upsert each occurrence
      for (const record of allRecords) {
        const { error: occError, data: occ } = await supabase
          .from('circle_meeting_occurrences')
          .upsert(
            {
              leader_id: record.leader_id,
              ccb_event_id: record.ccb_event_id,
              meeting_date: record.meeting_date,
              status: record.status,
              headcount: record.headcount,
              regular_count: record.regular_count,
              visitor_count: record.visitor_count,
              source: record.source,
              raw_payload: record.raw_payload,
              synced_at: new Date().toISOString(),
            },
            { onConflict: 'leader_id,meeting_date' }
          )
          .select('id')
          .single();

        if (occError) {
          console.error(
            `Upsert error for leader ${leader.id} on ${record.meeting_date}:`,
            occError
          );
          results.errors++;
          continue;
        }

        // 5. Upsert attendees (delete + re-insert for simplicity)
        if (occ && record.attendees.length > 0) {
          await supabase
            .from('circle_meeting_attendees')
            .delete()
            .eq('occurrence_id', occ.id);

          const { error: attError } = await supabase
            .from('circle_meeting_attendees')
            .insert(
              record.attendees.map((a) => ({
                occurrence_id: occ.id,
                ccb_individual_id: a.ccb_individual_id,
                name: a.name,
                attendance_type: a.attendance_type,
              }))
            );

          if (attError) {
            console.error(
              `Attendee insert error for occurrence ${occ.id}:`,
              attError
            );
          }
        }

        results.synced++;
      }
    } catch (err) {
      console.error(`Sync failed for leader ${leader.name} (${leader.id}):`, err);
      results.errors++;
    }
  }

  return NextResponse.json({
    success: true,
    dateRange: { startDate, endDate },
    ...results,
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET â€” summary / status check
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export async function GET(request: NextRequest) {
  const supabase = getServiceClient();

  // Optional: get stats for a specific leader
  const url = new URL(request.url);
  const leaderId = url.searchParams.get('leaderId');

  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  const sinceDate = sixMonthsAgo.toISOString().split('T')[0];

  let query = supabase
    .from('circle_meeting_occurrences')
    .select('status, meeting_date, synced_at')
    .gte('meeting_date', sinceDate)
    .order('meeting_date', { ascending: false });

  if (leaderId) {
    query = query.eq('leader_id', parseInt(leaderId, 10));
  }

  const { data: stats, error } = await query;

  if (error) {
    return NextResponse.json({ error: 'Failed to load stats', details: error }, { status: 500 });
  }

  const summary = {
    total: stats?.length || 0,
    met: stats?.filter((s) => s.status === 'met').length || 0,
    did_not_meet: stats?.filter((s) => s.status === 'did_not_meet').length || 0,
    no_record: stats?.filter((s) => s.status === 'no_record').length || 0,
    latestDate: stats?.[0]?.meeting_date || null,
    lastSyncedAt: stats?.[0]?.synced_at || null,
  };

  return NextResponse.json({ summary });
}
